前言：
JavaScript面向对象这个概念很是抽象，很难实际，可能未来接触框架代码层面会用到
自己做的笔记还有很多看不懂，学习JavaScript面向对象可以参考：https://github.com/mqyqingfeng/Blog

学习参考资料：https://github.com/mqyqingfeng/Blog

基本数据类型：按值访问，可操作保存在变量中的实际的值（undefined、null、string、number、Boolean）
引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在未对象添加属性时，操作的是实际的对象（object，array
RegExp、Date、Function、特殊的基本包装类型（string、number、Boolean）以及单体内置对象（Global、Math））；

面对对象编程：
JavaScript：通过原型（prototype）来实现面向对象编程。
JS原型对象（普通对象object和函数对象function）：
类：类是对象的类型模板。
实例：实例是根据类创建的对象。
JavaScript创建对象的两种方式：对象字面量和使用new表达式；
原型链：
原型链的核心：JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的__proto__属性；
当一个函数被定义时，JS引擎会为其添加prototype原型，然后在prototype上添加一个constructor属性，病让其指向该函数的引用；
通过new来创建一个新对象是，jS底层将新对象的原型链指向了构造函数的原型对象；
一般情况下，函数对象在产生时会内置name属性并将函数名作为赋值（仅函数对象）；

上下文（this？）：
给予对象、关键字this的值，代码再起内部工作的对象；
顶层JavaScript代码中声明的所有变量都将成晚全局对象的属性；
全局对象是由Object构造函数实例化的一个对象；

作用域（执行上下文）：
变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的，JavaScript没有块级作用域（ES6中有了块级作用域let），
只有函数作用域和全局作用域；JavaScript采用词法作用域（静态作用域）；

ECS（执行上下文栈）：变量提升、函数提升
执行上下文的生命周期两个阶段：
1、创建阶段：执行上下文会分别创建变量对象，建立作用域链以及确定this的指向；
2、代码执行阶段：完成变量赋值，函数引用，执行其他代码；
3、变量对象的创建过程：（函数声明比变量声明优先级高，同名函数会被后者覆盖，如果函数跟变量同名就会跳过，
等变量赋值的时候，变量也会覆盖函数原来的值。）
建立argument对象，检查当前上下文中的参数，建立该对象下的属性与属性值（全局环境下没有该操作）；
检查当前上下文的函数声明，如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖；
检查当前上下文的变量声明，如果该变量名的属性已经存在，为了防止同名的函数被修改未undefined，则会直接跳过，原属性值不会被修改；

闭包：
理论：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包；（函数+函数能够访问的自由变量）
一个主动执行的代码块，可以永久保存局部变量，形成一个独立的执行过程；
实践：即使创建它的上下文已经销毁，它依然存在（如内部函从父函数中返回），在代码中引用了自由变量

call、apply、bind：主要作用是改变函数中的this的指向；
call：在使用一个指定的this值和若干个指定的参数值得前提下调用某个函数或方法；
bind：创建一个新函数，当这个新函数被调用时，bind（）的第一个参数将作为它运行时的this，之后的参数将会在
传递的实参钱传入作为他的参数；
apply和call的唯一区别是第二个参数的传递方式不同，apply的第二个参数必须是一个数组，而call允许传递一个参数列表；

构造函数new实现JavaScript的继承
1、继承：
function Parent （name） {
this.name = name;
this.colors = ['red', 'blue', 'green'];
}
Prarent.prototype.getName = function(){
console.log(this.name);
}
function Child (name, age) {
Parent.call(this, name);
this.age = age;
}
2、组合继承：
Child.prototype = new Parent();
3、寄生组合继承：
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}
function prototype(child, parent) {
    var prototype = object(parent.prototype);
    prototype.constructor = child;
    child.prototype = prototype;
}
创建实例：
var child1 = new Child('cc', '18');
child1.colors.push('black);
var childs = new Child('ccc', '20');

JS执行环境（暂看不懂。。。）：http://www.cnblogs.com/onepixel/p/5090799.html，
commonJS是浏览器环境之外构建JavaScript生态系统为目标产生的项目，规范是为了解决JavaScript的作用域问题而定义的模块形式。
exports或module.exports来导出需要暴露的接口；允许模块通过require 方法来同步加载所要依赖的其他模块；






